---
layout: post
lang: ru
ref: python_super
title: "Python - о множественном наследовании и функции super() простыми словами"
comments: true
tags: [Python]
redirect_from: "/posts/ru/python_super/"
---

Python позволяет указать для класса несколько родителей.
Это называется множественным наследованием.
Я не рекомендую использовать эту технику бездумно и не к месту, но порой она очень
выручает.

Например, если мы хотим добавить какие-то общие свойства нескольким разным классам.
Добавлять эти свойства, через класс-наследник для каждого из классов явно некрасиво,
нарушает принцип [DRY](https://ru.wikipedia.org/wiki/Don’t_repeat_yourself).

Если речь о чем-то простом, то это можно сделать через 
[декоратор](https://www.python.org/dev/peps/pep-0318/).
Но если это что-то более развесистое и прикладное, то напрашивается оформить это
как объект, и добавить к нужным классам как [mixin](https://ru.wikipedia.org/wiki/Примесь_(программирование)).

При этом надо учитывать ряд нюансов, не специфичных для Python, а неизбежно возникающих 
при множественном наследовании, в частности "ромбы" (см.ниже).
Кроме того, конкретно в Python есть волшебная функция `super()` которая может вводить
в заблуждение тех, кто не понимает механизма ее работы. Особенно запутаться могут
программисты с опытом работы на java - они могут подумать, что это аналог `super` в java,
но это совсем не так. Что на самом деле делает эта функция я далее описываю в упрощенном виде.


![](/images/diamond_uml.png){:style="float: right;margin-right: 7px;margin-top: 7px;"}
![](/images/object_diamond_uml.png){:style="float: right;margin-right: 7px;margin-top: 7px;"}

## Проблема ромбов при множественном наследовании
Если у класса есть несколько родителей, а у родителей есть общий предок, получаем 
ромб в дереве наследования, как видно на диаграмме `Platypus` (утконос).

Утконос это млекопитающее, обладающее также свойствами рептилиии. 
Таким образом, он формально подходит для множественного наследования - к 
млекопитающему надо добавить свойства рептилии.
Чтобы сделать ситуацию веселеее, в качестве 
[mixin](https://ru.wikipedia.org/wiki/Примесь_(программирование))
я использовал не рептилию, а птицу. 

Поскольку в Python 3 классы, для которых явно не указан предок, наследуются от 
`object`, любая ситуация множественного наследования в Python 3 является 
ромбовидной - в конечном итоге все классы-родители унаследованы от `object`, 
как показано на диаграмме для `ObjectWithMixin`.

Строго говоря, и в диаграмме для `Platypus`, класс `Animal` наследуется от `object`,
но я не стал это визуализировать, чтобы не загромождать диаграмму.

В англоязычной документации ромбы при множественном наследовании называют 
[diamond problem](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem).

## Алгоритм C3 поиска в дереве наследования классов Python 3 (MRO)

Для поиска методов и полей в дереве родителей (MRO), Python использует 
[C3 алгоритм](https://ru.wikipedia.org/wiki/C3-линеаризация).

MRO расшифровывается как method resolution order - не слишком удачное название, 
учитывая, что так ищутся не только методы, но и поля.

Совсем упрощенно C3 алгоритм MRO можно представить так:

* в список добавляются родители объекта

  * в конец списка добавляет список родителей этих родителей
  * и так далее
  
* если какой-то класс оказывается в списке дважды, то оставляется только
последнее его вхождение.

Как результат, мы движемся по слоям, не обращаемся к классу-предку до 
того, как обратимся ко всем его потомкам, даже если потомков у этого
предка несколько.

Например, для класса `Platypus`, MRO будет `[Mammal, Bird, Animal]`.
Вначале ищем в классах `Mammal` и `Bird`, и,  только если не найдет 
там, в `Animal`.

Алгоритм обеспечивает поиск переопределенного метода класса-предка, если
этот метод переопределен хотя бы в одном потомке этого класса-предка.  

Python 2 использовал другой алгоритм (deep first), MRO для Python 2
`[Mammal, Animal, Bird]` - если бы он не нашел метод в `Mammal`, далее стал 
бы искать выше по иерархии, в `Animal`, а не в  следующем по списку 
множественного наследования предке, `Bird`. 

С алгоритмом deep first, использовать множественное наследование в Python 3
практически было бы невозможно, поскольку, как сказано выше, любое множественное
наследование в Python 3 является ромбовидным. 
Для Python 2 MRO выглядел бы как `[Mixin, MixinParent, object, Parent]` 
и уже после первого родителя мы бы "проваливались" до `object` и использовали 
бы реализованые в нем методы, даже если они переопределены в других родителях. 
Для Python 3 MRO будет `[Mixin, MixinParent, Parent, object]`.

## Иллюстрация множественного наследование

Даже если первый родитель `Platypus` (`Mammal`) не переопределяет искомый метод, 
а второй (`Bird`) переопределяет, мы не провалимся до `Animal`, а вызовем метод, 
переопределенный вторым родителем.
Поскольку ищем по алгоритму MRO (`[Mammal, Bird, Animal]`)

{% highlight python %}
{% include src/animal_mro_without_super.py %}
{% endhighlight %}
    Draw beak

## Функция super()

Функция super() обеспечивает так называемое "кооперативное" наследование методов.
Если во всех переопределенных методах использовать эту функцию, то она обеспечит 
вызов методов всех классов по алгоритму MRO.

`super()` это не класс-родитель, это объект, позволяющий вызвать следующий по  
алгоритму MRO класс.

Название `super()` вводит в заблуждение - как показано ниже, `super()`
вполне может найти метод не в родителе, а в "брате", если тот следует далее 
по алгоритму MRO.

Это может привести к изменению поведения класса, если мы его добавляем в
дерево наследования. Он начнет вызывать метод не родителя, как делал, когда
не был добавлен в дерево множественного наследования, а другого класса, который
переопределил метод родителя. 

Вполне может быть, что нам этого и
хотелось бы (скажем, мы добавили класс, который переопределяет что-то в `object`,
и хотим чтобы это сказалось на всех классах в дереве наследования).
Но в каких-то ситуациях это может оказаться неприятной и трудно обнаружимой
проблемой.

![](/images/animal_class_tree_uml.png){:style="float: right;margin-right: 7px;margin-top: 7px;"}

## Иллюстрация кооперативного множественного наследования с помощью super()


{% highlight python linenos %}
{% include src/animal_class_tree.py %}
{% endhighlight %}
[... Выполнить код ...](https://trinket.io/python3/87415de54d){:target="_blank"}{:style="background-color: WhiteSmoke;text-align: center;border: 1px solid silver;display: inline-block;width: 100%;"}

    Platypus.__init__()
    Mammal.__init__()
    Bird.__init__()
    Animal.__init__()


Если хоть один наследник нарушает принципы кооперативного наследования (не
вызывает `super()`), то метод родителя вообще не будет вызван, хотя
вроде бы мы имеем явный вызов этого родителя из другого наследника.

Например, давайте закомментарим вызов `super()` в классе `Bird` (строка 8). 
Вывод изменится следующим образом:

    Platypus.__init__()
    Mammal.__init__()
    Bird.__init__()
    
Причина в том, что из `Mammal.__init__` вызывается следующий по MRO класс
(`Bird`), а вовсе не родитель `Mammal` (`Animal`). 
Родителя ранее вызывал `Bird`, но мы убрали этот вызов.

В коде ниже я добавил аргументы в `__init__`, чтобы проиллюстрировать сказанное
выше выдаваемой ошибкой.

{% highlight python linenos %}
{% include src/animal_class_tree_arguments.py %}
{% endhighlight %}
    Platypus.__init__()
    Mammal.__init__()
    ...
    File "animal_class_tree_arguments.py", line 13, in __init__
        super().__init__()
    TypeError: __init__() missing 1 required positional argument: 'beak_length'

Ошибка показывает, что в `Mammal` код `super().__init__()` пытается 
вызвать `Bird.__init__`.

#### Примечание - особенности работы super()

Одним из ограничений `super()` является то, что не получится выполнить операции
([binary operations](https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations),
[subscriptions](https://docs.python.org/3/reference/expressions.html?highlight=slice#subscriptions)
и т.д.)
над возвращенным объектом, даже если эти операции реализованы в родителе 
вызывающего класса с помощью 
["магических методов"](https://docs.python.org/3/library/operator.html). 

Если выполнить операцию над экземпляром класса, то Python найдет
нужный для выполнения операции "магический метод" в родителе (в примере ниже -
`__getitem__` для индексирования с помощью оператора `[]`).

Но если попытаться выполнить операцию над объектом, возвращаемым `super()`, 
получим ошибку:

{% highlight python %}
{% include src/super_operations.py %}
{% endhighlight %}

    kid[0]: 0
    ...
    TypeError: 'super' object is not subscriptable
    
