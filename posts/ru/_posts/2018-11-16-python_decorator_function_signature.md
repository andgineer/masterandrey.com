---
layout: post
lang: ru
ref: python_decorator_function_signature
title: "Декораторы Python и сохранение набора параметров декорированной функции (__signature__)"
comments: true
tags: [Python decorator]
redirect_from: "/posts/ru/python_decorator_function_signature.md/"
---

## Проблема

[Декораторы](https://docs.python.org/3/library/doctest.html) подменяют исходную 
функцию.

И при этом изменяет ее "сигнатуру" - набор параметров.
У новой функции уже будет тот набор параметров, что в возвращенной декоратором 
функции, а не тот, что был у исходной.

Порой, это может создать проблемы.
Например, если мы далее передаем эту функцию фреймворку swagger transmute,
который автоматически строит swagger описание нашего API, анализируя наши
обработчики запросов.
Этот фреймворк описывает в swagger параметры запросов исходя из
 параметров наших функций- обработчиков этих запросов.
 
Но если мы обернули с какой-то целью наш обработчик например в такой 
декоратор:

{% highlight python %}
{% include src/decorator.py %}
{% endhighlight %} 

то фреймворк уже не увидит исходных параметров.
 
Он будет видеть только безликие `*args, **kwargs`.
И не построит нам корректного swagger-описания.

## Как сохранить исходный набор параметров декорированной функции

Как описано в
[PEP0362](https://www.python.org/dev/peps/pep-0362/#visualizing-callable-objects-signature)
в Python, начиная с 3.3, можно подменять сигнатуру функции с помощью 
атрибута `__signature__`:

{% highlight python %}
{% include src/decorator2.py %}
{% endhighlight %}

## Как сохранить прочие атрибуты функции после декорирования

Помимо этого, скорее всего мы также захотим сохранить еще ряд атрибутов функции.

Например, `__doc__`, что весьма немаловажно, как для автоматического создания 
документации, так и для [doc-tests](https://docs.python.org/3/library/doctest.html) 
- преставьте, что иначе вы потеряете doc-тесты исходной функции.

Атрибуты исходной функции можно сохранить с помощью декоратора 
`wraps` модуля `functools`:

{% highlight python %}
{% include src/decorator2.py %}
{% endhighlight %}

Немного неудобно, что `__signature__` надо сохранять отдельно. 

К сожалению, вы не можете указать `wraps` сохранять также `__signature__`.
Для `wraps` можно указывать произвольный список сохраняемых атрибутов, но 
`__signature__` скорее всего не является атрибутом исходной функции.
Потому что `__signature__` не добавляется ко всем функциям автоматически, хотя
и корректно используется, если уже добавлено. 
Поэтому этот атрибут и приходится получать с помощью `inspect`, а не копированием 
из исходной функции с помощью `wraps`.
